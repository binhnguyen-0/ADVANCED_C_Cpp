<a name="top"></a>
# 📖 AUTOSAR FUNDAMENTAL
----
<details>
<summary>🔖 <b>AUTOSAR</b></summary>

### 📑 I. Giới thiệu:

- AUTOSAR (Automotive Open System Architecture) là một kiến trúc phân lớp dùng để tiêu chuẩn hóa các hệ thống nhúng trong ô tô.
- Ưu điểm:
  - Khả nawg tái sử dụng phần mềm cao với các dự án khác nhau.
  - Dễ dàng thay đổi để tương thích với các dòng MCU khác nhau.
  - Trừu tượng: tách biệt phần mềm và phần cứng để phát triển linh hoạt.
  - Dễ quản lý và bảo trì phần mềm.
- Có 2 loại:
  - Classic AUTOSAR.
  - Adaptive AUTOSAR.

### 📑 II. Classic AUTOSAR:
  
- Cấu trúc kiến trúc gồm có 3 lớp chính:
    1. Application Layer:
       - Là lớp trên cùng, chứa các SWC (Software Components) - các khối phần mềm trong hệ thống, mỗi SWC đại diện cho mỗi chức năng cụ thể trong hệ thống.
       - Các SWC độc lập và có thể giao tiếp với nhau và các thành phần khác thông qua RTE.
       - Chỉ tập trung xử lý logic, không liên quan đến phần cứng.
    2. Runtime Environment (RTE):
       - Là lớp trung gian, đảm nhiệm việc giao tiếp giữa các SWC và giữa các SWC với các BSW.
    3. Basic Software (BSW):
       - Chia thành 3 lớp chính:
         - Services: Cung cấp các dịch vụ hệ thống, tiện ích và quản lý cần thiết để hỗ trợ các lóp phần mềm ứng dụng và BSW khác.
         - ECU Abstraction Layer (EAL): Là lớp trừu tượng hóa tất cả các thiết bị ngoại vi và phần cứng cụ thể của ECU như là các cảm biến mà ECU sử dụng.
         - Microcontroller abstraction Layer (MCAL): Là lớp trừu tượng giao tiếp trực tiếp với phần cứng như GPIO, ADC, PWM, ...


### 📑 I. Khái niệm:

#### 1. Tính đóng gói: 

- Tính đóng gói (Encapsulation) là ẩn đi các property khỏi người dùng. Nghĩa là khai báo các property ở quyền truy cập private hoặc protected, không thể truy cập chúng từ các object bên ngoài.

```cpp
class SinhVien
{
    private:
        string name;    // tính đóng gói
        int age;        // tính đóng gói
        int id;         // tính đóng gói
}
```

#### 2. Tính trừu tượng: 

- Tính trừu tượng là ẩn đi các hàm khỏi người dùng. Nghĩa là khai báo các hàm ở quyền truy cập private hoặc protected, không thể truy cập chúng từ các object bên ngoài.

```cpp
class SinhVien
{
    private:
       /* Tính trừu tượng: khai báo, định nghĩa hàm ở cấp private*/
        // Hàm kiểm tra xem tên có hợp lệ không
        bool checkName(string str)
        {
            for (int i = 0; i < str.length(); i++)
            {
                char c = str[i];
                if (!((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c == ' ')))
                {
                    return false;
                }
            }
            return true;
        }

        // Hàm kiểm tra xem tuổi có hợp lệ không
        bool checkAge(int age)
        {
            if (age <= 0) return false;
            return true;
        }
}
```

- Hàm setter dùng để cài dữ liệu, còn hàm getter dùng để lấy dữ liệu.

```cpp
class SinhVien
{
    private:
        string name;
        int age;
        int id;

    public:
        // Constructor
        SinhVien()
        {
            static int _id = 1;
            id = _id;
            _id++;
        }

        // setter
        void setName(string newName)
        {
            if (checkName(newName))
            {
                name = newName;
            }
            else
            {
                cout << "Unvalid name !" << endl;
                name = "";
            }
        }

        // setter: đặt dữ liệu
        void setAge(int newAge)
        {
            if (checkAge(newAge))
            {
                age = newAge;
            }
            else
            {
                cout << "Unvalid age !" << endl;
                age = 0;
            }
        }

        // getter: lấy dữ liệu
        string getName()
        {
            return name;
        }

        // Hàm hiển thị
        void display()
        {
            cout << "Tên: " << getName << endl;
            cout << "Tuổi: " << age << endl;
            cout << "MSV: " << id << endl;
        }
};
```

#### 3. Tính kế thừa: 

- Một class có thể sử dụng lại những property hay method được khai báo trong những class khác.
- Chỉ có thể kế thừa được những property và method ở cấp độ public, protected trong base class còn private thì không thể kế thừa.
- Cú pháp:
  - `class derivedclass : public baseclass`
  - Đa kế thừa: `class derivedClass : public baseclass1, protected baseclass2, private baseclass3`
- Có 3 kiểu kế thừa:
  - public, private và protected.

- Cách truy cập của các property hay method trong base class:

|Cấp độ truy cập|Base class|Derived class|Thông qua object|
|:---:|:---:|:---:|:---:|
|`public`|✔️|✔️|✔️|
|`protected`|✔️|✔️|❌|
|`private`|✔️|❌|❌|

- Cách chuyển đổi cấp độ truy cập khi kế thừa từ các cấp truy cập của base class:

|Kiểu kế thừa|public|protected|private|
|:---:|:---:|:---:|:---:|
|`public`|giữ nguyên|giữ nguyên|không kế thừa|
|`protected`|protected|protected|không kế thừa|
|`private`|private|private|không kế thừa|

> 👉 Ví dụ: Các trường hợp kế thừa cấp độ public, protected, private.

<details>
<summary>🔖 <b>main.cpp</b></summary>
  
```cpp
#include <iostream>
#include <string>

using namespace std;

class BaseClass
{
    public:
        int a;
    
    protected:
        int b;

    private:
        int c;
};

class publicDerivedClass : public BaseClass
{
    public:
        void testPublic()
        {
            a = 1;          // truy cập được vào cấp public
            b = 2;          // truy cập được vào protected
            // c = 3;       // không thể truy cập vào cấp private của BaseClass
        }

};

class protectedDerivedClass : protected BaseClass
{
    public:
        void testProtected()
        {
            a = 1;          // truy cập được vào cấp public và trở thành protected trong protectedDerivedClass
            b = 2;          // truy cập được vào cấp protected và trở thành protected trong protectedDerivedClass
            // c = 3;       // không thể truy cập vào cấp private của BaseClass
        }

};

class privateDerivedClass : private BaseClass
{
    public:
        void testPrivate()
        {
            a = 1;          // truy cập được vào cấp public và trở thành private trong privateDerivedClass
            b = 2;          // truy cập được vào cấp protected và trở thành private trong privateDerivedClass
            // c = 3;       // không thể truy cập vào cấp private của BaseClass
        }

};

int main()
{
    // Kế thừa public
    publicDerivedClass pb;
    pb.a = 1;                   // a giữ nguyên là public
    //pb.b = 2;                 // b giữ nguyên là protected: không truy cập được từ bên ngoài
    //pb.c = 3;                 // c giữ nguyên là private: không được kế thừa

    // Kế thừa protected
    protectedDerivedClass pt;
    //pt.a = 1;                 // a trở thành protected: không truy cập được từ bên ngoài
    //pb.b = 2;                 // b trở thành protected: không truy cập được từ bên ngoài
    //pb.c = 3;                 // c giữ nguyên là private: không được kế thừa

    // Kế thừa private
    privateDerivedClass pv;
    //pt.a = 1;                 // a trở thành private: không truy cập được từ bên ngoài
    //pb.b = 2;                 // b trở thành private: không truy cập được từ bên ngoài
    //pb.c = 3;                 // c giữ nguyên là private: không được kế thừa
}
```

</details>

[🔼 _UP_](#top)

</details>

